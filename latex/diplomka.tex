%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\documentclass[12pt]{report}

\usepackage{tocloft}

%\setlength\cftparskip{-2pt}
%\setlength\cftbeforechapskip{0pt}

\usepackage{xecyr}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}

%\usepackage[utf8x]{inputenc}
%\usepackage[english,russian]{babel}

\usepackage[top=2.5cm, bottom=2.5cm, left=3cm, right=2.5cm]{geometry}                
% See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
%\usepackage{amssymb}

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{}
\rhead{\footnotesize{Система слежения за лицом человека}}
\cfoot{}
\rfoot{\thepage}

\pagenumbering{arabic}

\usepackage{setspace}
\onehalfspacing

\usepackage{fontspec,xltxtra,xunicode}
\defaultfontfeatures{Mapping=tex-text}
\setromanfont[Mapping=tex-text]{Times New Roman}
\setsansfont[Scale=MatchLowercase,Mapping=tex-text]{Gill Sans}
\setmonofont[Scale=MatchLowercase]{Andale Mono}

% Will Robertson's fontspec.sty can be used to simplify font choices.
% To experiment, open /Applications/Font Book to examine the fonts provided on Mac OS X,
% and change "Hoefler Text" to any of these choices.


\setlength{\parindent}{0cm}
\setlength{\parskip}{12pt plus 0.5ex minus 0.2ex}
\renewcommand{\headrulewidth}{0pt}

%\title{Искусственный интеллект в играх на примере игры "Войны планет"}
%\author{Александр Мочёнов}
%\date{26 Октября 2010 г.}                                           
% Activate to display a given date or no date

\usepackage{titlesec}
\titleformat{\chapter}[hang]{\bf\normalsize\uppercase}{\thechapter}{2pc}{}
\titleformat{\section}[hang]{\bf\normalsize}{\thesection}{2pc}{}	
\titleformat{\subsection}[hang]{\bf\normalsize}{\thesubsection}{2pc}{}
\titlespacing{\chapter}{0pt}{*4}{*1}

\usepackage{hyperref} 
%\usepackage{graphicx}
\usepackage{pstricks}
%\DeclareGraphicsExtensions{.png}

%\newcommand{\executeiffilenewer}[3]{%
% \ifnum\pdfstrcmp{\pdffilemoddate{#1}}%
% {\pdffilemoddate{#2}} >0 {\immediate\write18{#3}}\fi%
%}
%
%\newcommand{\includesvg}[1]{%
%\executeiffilenewer{#1.svg}{#1.pdf}%
%{inkscape -z -D --file=#1.svg --export-pdf=#1.pdf --export-latex}%
%\input{#1.tex}%
%}
\usepackage{subfig}

\usepackage{url}

\usepackage{natbib}
\bibpunct{(}{)}{;}{a}{,}{,}

\newenvironment{myItemize}{
	\begin{itemize}
  		\setlength{\itemsep}{1pt}
  		\setlength{\parskip}{0pt}
  		\setlength{\parsep}{0pt}
}{\end{itemize}}

\newenvironment{myEnumerate}{
	\begin{enumerate}
  		\setlength{\itemsep}{1pt}
  		\setlength{\parskip}{0pt}
  		\setlength{\parsep}{0pt}
}{\end{enumerate}}

\usepackage{totcount}
\regtotcounter{figure}
\regtotcounter{table}
\regtotcounter{chapter}

\usepackage[acronym,toc]{glossaries}
\makeglossaries
%\input{glossary}


\renewcommand{\cfttoctitlefont}{\normalsize\textbf}
\setlength{\cftaftertoctitleskip}{18pt}


\usepackage{listings}
\usepackage{algorithmic}


\begin{document}
%\renewcommand{\chaptername}{} 
%\renewcommand{\thechapter}{} 
%\renewcommand{\thesection}{\arabic{section}} 

\begin{titlepage}
  \begin{center}
	\uppercase{Высшая школа майнор}\\*
	Институт инфотехнологии\\*
	Веб программирование\\[8cm]
	Александр Мочёнов\\*
	IT-3-Q-V-Tal\\[0.5cm]
	\large
	\textbf{Система (? Метод ?) обнаружения и слежения за положением лица человека на основе нейронных сетей и 
сегментации по цвету кожного покрова (? по цвету кожи?)}\\[1cm]
	\normalsize
	Дипломная работа\\[2cm]
	\begin{flushright}
		Руководитель: Jelena Faronova, MSc\\[6cm]
	\end{flushright}
	Таллинн 2010
  \end{center}
\end{titlepage}

\tableofcontents{\thispagestyle{fancyplain}}

\chapter*{Резюме}
\addcontentsline{toc}{chapter}{Резюме}
\thispagestyle{fancy}

TODO:

%\printglossary[title=Терминалогия и переводы,style=fancy,toctitle=Терминалогия и переводы]

\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}
\thispagestyle{fancy}

Роботы в различных вариациях являются частью жизни человека. Робототехника уже
давно применяются, например, в индустриальном производстве, в детских игрушках,
авиации и многих других местах. Так же роботы применяются в военными (беспилотные
самолёты, роботы-сапёры), медицине и даже в космосе\footnote{\url{http://robonaut.jsc.nasa.gov/default.asp}}.

Тем не менее, применение роботов в сфере обслуживания сегодня не так распространенно. Оно находится на рубеже науки 
робототехники и пока ещё широко не применяется. В данной работе автор разрабатывает небольшую
часть робота, функционирующего в сфере обслуживания, главной целью которого
является общение с человеком. 

Цель автора данной работы - создать интерактивную систему слежения за человеческим лицом подобием головы робота, 
которая оборудована веб-камерами на месте глаз и серво-приводами, способными поворачивать её по двум осям. Вся 
система состоит из 3 модулей:
\begin{myItemize}
\item Нахождение местоположения и размеры лиц людей на изображении с веб-камеры
\item Выбор лица из найденных, за которым необходимо следовать
\item Вычисления вектора движения и само общение с серво-приводами
\end{myItemize}

Самой сложной из задач является поиск лица человека. В работе автор предлагает последовательный алгоритм поиска, 
который состоит из 3 подзадач, где результат предыдущей является источником данных для последующего:
\begin{myItemize}
\item Предварительная обработка и подготовка изображения;
\item Поиск, сегментация и кластеризация участков кадра, в которых высока вероятность обнаружения лица;
\item Применение искусственных нейронных сетей для окончательной классификации (лицо или нет) по нескольким 
представлениям данного изображения;
\end{myItemize}

TODO: Почему именно такой?

TODO: Про real-time сюда?

Подобная система может применяться в любых роботах, обладающих подобием головы.
Например: робот-консьерж в отеле, робот-официант или робот-домохозяйка. Это может упростить и улучшить
впечатление от общения человека с машиной.

TODO: Содержание глав

\chapter{Введение в предметную область}
\thispagestyle{fancy}

%(Про Computer Vision в целом.)
\section{Компьютерное зрение}

Основной частью данной работы является обработка изображений поступаемых с веб-камеры. Трансформация данных с видео 
камеры или из статичных изображений в новое представление или принимаемое решение называется - \emph{Компюьтерным 
Зрением} (\texttt{Computer Vision} или \texttt{CV})\citep{bradski2008learning} Т.е. программы и алгоритмы, которые в 
своей работе используют визуальную информацию - всё это компьютерное зрение.

Человеку, в силу своей зрительной природы, может показаться, что обработка визуальной информации - это очень просто. 
Но эта представление крайне ошибочно. Наш мозг разделяет визуальную информацию на множество каналов, в которых 
зашифрованы различные винды информации и посылает их мозг человека. В мозгу есть системы распределения внимания, в 
ходе работы корой, часть информации обрабатывается, а часть остаётся незамеченной. \citep{bradski2008learning} Даже 
сетчатка глаза - внутренняя поверхность глаза, заполненная светочуствительными клетками (колбочками и палочками), 
отвечает за предворительную обработку сигнала. На поверхности глаза около 130 миллионов светочувствительных 
элементов, а нервных окончаний идущих к мозгу в 100 раз меньше. Это говорит о том, что сетчатка сжимает информацию. В 
частности одной из её функций является \emph{обнаружение границ} \texttt{Edge detection}) \citep{RetinaOnWiki}

А что ``видит'' компьютер? Матрицу из чисел, представляющих собой интенсивность света в разных участках 
светочувствительной матрицы. При этом каждая ячейка этой матрицы кроме полезной информации содержит ещё и шум. И в 
этом наборе чисел надо найти машину или, например, идущего человека.

%Где и зачем применяется face detection?
Компьютерное зрение широко применяется в медицине, где оно помогает человеку анализировать визуальные данные. 
Например по снимку с МРТ\footnote{Магнитно-резонансная томография} указать на опухоль (рис.  \ref{fig:mri}) или 
анализировать клетки крови (рис. \ref{fig:blood_cells}) . Это задача называется \emph{распознаванием образов} 
(\texttt{Pttern recognition}). Распознавать можно так же и другие объекты и образы. Например, система автоматического 
замера скорости на дорогах распознаёт автомобили и их регистрационные номера, а система безопасности распознаёт 
передвижение людей (рис. \ref{fig:track_people}) или запрщённые объекты в багаже (рис. \ref{fig:piston}).

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:mri}
		\includegraphics[width=0.24\textwidth]{Pictures/kwock3}}
%	\hspace{0.1cm}
	\subfloat[]{
		\label{fig:blood_cells}
		\includegraphics[width=0.24\textwidth]{Pictures/celltracking}}
%	\hspace{0.1cm}
	\subfloat[]{
		\label{fig:piston}
		\includegraphics[width=0.24\textwidth]{Pictures/3d_sift_crop}}
%	\hspace{0.1cm}
	\subfloat[]{
		\label{fig:track_people}
		\includegraphics[width=0.24\textwidth]{Pictures/Reading_People_Tracker_crop}}		
		
	\caption{Примеры приминения Компьютерного зрения: \subref{fig:mri} Обозначенная опухоль на снимке МРТ, \subref
{fig:blood_cells} Анализ клеток с помощью CV, \subref{fig:piston} Определение запрещённых предметов, \subref
{fig:track_people} Слежение за людьми службой безопасности}
	\label{fig:cv_usage}
\end{figure}

%Про Machine Learning в целом?

\emph{Распознавание лица} (\texttt{Face recognition}) человека является одной из наиболее популярных задач в области 
компьютерного зрения. Она заключается в обнаружение и определении по изображению лица кому именно оно принадлежит. 
Решения этой проблемы применяются в системах безопасности (авторизация) и системах управления базами данных лиц 
людей. %TODO More Use cases
С быстрым развитием более развитых методов в этой области, распознавание лица человека, как средство авторизации, 
представляет из себя более дешёвое решение по сравнению с системами распознавания сетчатки глаза или отпечатка 
пальца. \citep{kumar2006efficient}

В популярной программе для работы с цифровыми фотографиями Picasa (\url{http://picasa.google.com/}) есть эффективная 
система распознавания, маркировки и каталогизирования найденных на фотографиях лиц людей (рис. \ref{fig:picasa}). 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{Pictures/picasa}
	\caption{Интерфейс программы Google Picasa с частью списка найденных на фотографиях лиц.}
	\label{fig:picasa}
\end{figure}

\section{Распознавание и обнаружение лиц}

Но для того, что бы распознать лицо, сначала необходимо найти его место положение и границы на изображении. Эта 
задача называется \emph{обнаружение лица} (\texttt{Face detection}), что является частным случаем более общей 
проблемы \emph{обнаружение объекта} (\texttt{Object detection}). Почти все алгоритмы распознавания лиц в качестве 
входных данных используют изображение, содержащее только лицо, которое надо распознать. По-этому обнаружение лица 
есть предварительная и очень важная задача, которую надо выполнить, перед распознаванием. Следовательно от точности и 
быстроты определения местоположения лица зависит эффективность всей задачи по распознаванию. 

Но, обнаружение не обязательно должно вести к распознаванию. Обнаружение и слежение за лицом без определения 
пренадлежности его к конкретному человеку является основной задачей как данной работы, так и схожих по своей сути 
работ: \citep{capi2010vision}, \citep{luo2007face}, \citep{saxena2008real}.

Нахождение лица заключается в том, что бы по данному изображению определить, количество, место положения и размеры 
всех имеющихся лиц. (рис. \ref{fig:sampledetection}) \citep{liu2010automatically}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{Pictures/sampledetection}
	\caption{Обнаружение всех лиц на изображении и обозначение их прямоугольником.}
	\label{fig:sampledetection}
\end{figure}

\section{Существующие методы обнаружения лиц}

Почти все современные подходы к решению задачи обнаружения лица, по мнению автора, содержат так или иначе 3 
составляющих:

\begin{description}

%\begin{description}
\item[Подготовка данных]\hfill \\
	Для успешного обнаружения лица поступившие данные необходимо подготовить для дальнейшей работы. Сюда входят и 
различные методы \emph{предварительные обработки} изображения в целом (т.н. \texttt{preprocessing}) и методы 
позволяющие уменьшить область поиска или \emph{область интереса} (\texttt{Region of interest} или \texttt{ROI}) для 
ускорения всего процесса обнаружения.
\item[Представление данных]\hfill \\ 
	Изначальное изображение в виде матрицы интенсивностей светочувствительного элемента камеры часто трансформируют в 
иные, более компактные отображения или \emph{представления} (\texttt{Representation}). Такие изменения чаще всего 
ведут к потере информации, но облегчают процесс классификации.
\item[Классификация]\hfill \\ 
	Само определение наличия или отсутствия в данном участке картинки лица человека. Методов классификации в принципе 
(не только лиц) на сегодняшний день существует огромное количество и все они применимы для данной задачи.
\end{description}

\subsection{Методы предварительной подготовки данных}
\subsubsection{Коррекция цвета и освещённости}
\label{sec:preprocessing_theor}
Для эффективной работы с изображением его необходимо подготовить.(О проблеме освещения в принципе)

Некоторые механизмы применяются для всего изображения в целом. Например, коррекция контраста или интенсивности и 
баланса белого (рис \ref{fig:people1}). Другие подготовительные процессы касаются изображений, которые поступают 
непосредственно в классификатор. Речь идёт о небольших частях изображения, которые получаются методов скользящего 
окна (\texttt{sliding window}) и маштабирования, которые называют \emph{образцами} (об этом подробнее в (TODO)). 
Процессы коррекции контраста и баланса белого часто накладывают и на образцы (рис \ref{fig:people_faces}), т.к. 
зачастую после исправления контрастности всего изображения, распределение интенсивности в образце всё ещё остаётся 
узким.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:people1}
		\includegraphics[width=0.8\textwidth]{Pictures/people.eps}
		}
	\subfloat[]{
		\label{fig:people_faces}
		\includegraphics[width=0.2\textwidth]{Pictures/people_faces.eps}
		}
	\caption{Нормализация всего изображения \subref{fig:people1} и дополнительная нормализация образца \subref
{fig:people_faces}}
	\label{fig:normalize_example}
\end{figure}

В работе \citep{rowley1998neural}, в частности, применяется два метода предворительной обработки образцов. Во-первых 
производится нелинейное \emph{уровновешивание гистограммы} (\texttt{Histogram equalization}), которое ``растягивает'' 
гистограмму, что компенсирует недостающие уровни интенсивности изображения, в результате чего изображение становиться 
более контрастным. Во-вторых производиться линейная компенсация интенсивности. Для этого линейная функция 
аппроксимирует общую яркость в каждой из частей образца, после чего она может быть вычтена из образца в случае 
сильной разницы в освещённости разных частей образца. Это приводит к уравновешиванию контрастности в разных частях 
образца (рис. \ref{fig:norm_grad}) 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{Pictures/norm_grad.eps}
	\caption{Метод линейной коррекции контрастности. На рисунке сверху оригинальное изображение, ниже результат 
измирения суммарной интенсивности, ниже результат вычитания. \citep{rowley1998neural}}
	\label{fig:norm_grad}
\end{figure}

Похожий алгоритм нормализации интенсивности применяется и в работе \citep{lin2005face}. Перед классификацией каждый 
образец нормализуется по формулам \ref{eq:lin2005_1} и \ref{eq:lin2005_2}.

\begin{equation}
\label{eq:lin2005_1}
\centering
\bar{I}=\frac{1}{N}\sum_{i=1}^{N}I_{i}
\end{equation}
\begin{equation}
\label{eq:lin2005_2}
\centering
{I}'_i=(I_i-\bar{I})+128
\end{equation}

\begin{tabular}{p{3cm} c l}
где & $N$ & -- количество пикселей в образце\\
	& $\bar{I}$ & -- средняя интенсивность по всем пикселям образца\\
	& $I_i$ & -- интенсивность $i$'ого пикселя образца\\
	& ${I}'_i$ & -- нормализированная интенсивность\\
\end{tabular}

Таким образом если какие-то образцы были слишком тёмными или слишком светлыми они все становятся единообразно 
освещены, что упрощает процесс машинного обучения. Пример показан на рисунке \ref{fig:gray_norm}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{Pictures/gray_norm.eps}
	\caption{Приминение формул \ref{eq:lin2005_1} и \ref{eq:lin2005_2}.}
	\label{fig:gray_norm}
\end{figure}

Как видно, после преобразования образци стали однообразны, но при этом в большинстве случаев теряется много полезной 
информации. В данной работе применяются схожие методы предварительной обработки образцов и изображения в целом. 
Подробнее в разделе ....(TODO)

\subsubsection{Сегментация по цвету кожного покрова}
\label{sec:skin_segm}
Чем меньше изображние необходимо сканировать на наличие лица, тем меньше процессорного времени необходимо 
затрачивать, что ведёт к ускорению процесса обнаружение. Это можно достигнуть, например, уменьшением изображения, что 
приведёт к потере разрешающей способности данного подхода. Одним из способов позволяющих уменьшить площадь 
сканирования и одновременно не потерять разрешающей способности является эвртистическое знание о том, что все лица 
людей покрыти кожным покровом. Это можно использовать для нахождения областей изображения содержащих цвета схожие с 
цветами кожного покрова (\texttt{skin-color detection}), и в дальнейшем осуществлять сканировение только этих 
областей.

Среди методов обнаружения лиц основанных на поиске признаков (\texttt{feature based}) подходы использующие информацию 
о цвете кожи, как признак обнаружения, получают всё большую популярность. Цвет легко и быстро обрабатывать и он 
инвареантен к геометрическим особенностям образов лиц людей. К тому же опыт подсказывает, что цвет кожи человека 
имеет отчётливый характерный цвет, который легко узнаваем людьми. \citep{vezhnevets2003survey} Цвет кожи - это один 
из тех признаков, что не зависит от положения лица, частичной закрытости и контраста, по-этому именно этот метод 
часто используют для локализации лиц. \citep{ruangyam2009efficient}

Такой метод возможен благодаря тому факту, что различные цветовые вариации кожных покровов людей (даже среди 
представителей различных этнических групп) лежат в достаточно узком диапазоне и отличаются только яркостью (\texttt
{Luminance}), в тож время цветность (\texttt{chrominance}) практически не меняется. Цвет кожи лежит в основном в 
красной части цветового спектра и определяется цветом крови. А яркость определяется прозрачностью эпидермиса 
(верхнего слоя кожи), за что в свою очередь отвечает концентрация меланина. \citep{xu2006color} Подробнее в 
разделе ... (TODO)

\subsection{Методы представления изображения}
Одно и тоже изображение можно представить разными способами. Это нужно для того, что бы обучаемые классификаторы (см. 
\ref{classficators}) могли обучаться на различных характеристиках или признаках, имеющихся в различных 
представлениях. 

\subsubsection{Пиксельная интенсивность}
Самым простым и популярным представлением является информация об интенсивности в каждом пикселе изображения. Такой 
метод представления считается не имеющим потерь (\texttt{lossless}). Т.е. в нём присутствует  вся информация об 
оригинальном изображении.\citep{bojkovic2006face} Пример на рисунке \ref{fig:house_gray}.

\subsubsection{Информация о контурах}
Любой метод обнаружения лица (да как и все другие алгоритмы в компьютерном зрении) должен быть стойким к таким вещам 
как поза голов, угол обзора, освещение и многим другим факторам. 

Для решения проблемы с освещением используется \emph{информация о контурах} (\texttt{edginess}) или \emph{градент 
изображения}. Одно и то же лицо под разными источниками света с точки зрения пиксельного представления совершенно 
отличны друг от друга, что делает проблемой для классификатора найти среди них нечто общее. С другой стороны 
информация о пограничных облостях в большей степени неизменна. \citep{ahmadyfard2008hierarchical}

Это представление, в отличая от пикселного представления, не содержит всей изначальной информации. Сохраняется 
информация лиш о пограничных контрастных зонах лица (глаза, брови, губы). Пример такого представления на рисунке \ref
{fig:house_gray_sobel}.

\subsubsection{Собственные лица}
\emph{Собственное лицо} (\texttt{eigenface}) - это набор \emph{собственных векторов} (\texttt{eigen vectors}), 
используемых для описания ``стандартезированных  компанентов лица''. Один образец лица принимается как точка в 
многомерном пространстве. Много образцов образуют некую область в этом пространстве. Задача заключается в нахождении 
\emph{главных компонент} (\texttt{principal components}) этой области, параметрами которых её можно описать используя 
значительно меньшее количество переменных, нежели для описания всех точек изначального пространства.\citep
{turk1991eigenfaces}

Собственный вектор представляет из себя набор параметров, которыми можно описать лицо человека. Их же можно хранить 
например в базе данных, или использовать в качестве представления группы изображений. Этот набор параметров является 
своего рода выжемкой из многих тренировочных лиц и может использоваться для дальнейшей классификации. Эти пораметры 
можно спроэцировать в виде изображения. Пример собственного лица приведёт на рисунке \ref{fig:eigenfaces}.

В работе \citep{tsai2006face} автор для обнаружения лиц использует собственные лица для поиска кондидатов областей с 
лицами, а нейронная сеть проводит конечную валидацию.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:house_gray}
		\includegraphics[width=0.3\textwidth]{Pictures/dr_house_gray.png}
		}
	\subfloat[]{
		\label{fig:house_gray_sobel}
		\includegraphics[width=0.3\textwidth]{Pictures/dr_house_gray_sobel.png}
		}
	\subfloat[]{
		\label{fig:eigenfaces}
		\includegraphics[width=0.35\textwidth]{Pictures/eigenfaces.jpg}
		}
	\caption{Различные представления изображений: \subref{fig:house_gray} обачное пиксельное представление, \subref
{fig:house_gray_sobel} нормализованный Собелев градиент по $y$, \subref{fig:eigenfaces} набор из различных 
собственных лиц}
	\label{fig:representations}
\end{figure}

\subsubsection{Характеристики типа Хаара}
\emph{Характеристики типа Хаара} (\texttt{Haar-like features}) представляют изображения в виде набора характеристик 
получинных вычитанием сум интенсивностей одних областей из других по определённому шаблону. Это представление 
применяется при использовании платформы по обнаружению объектов Виола-Джонса (\texttt{Viola-Jones object detection 
framework}). \citep{viola2001rapid}
Эта метод и применяемое в нём представление является одним из самых быстрых на сегодняшний день методов обнаружения 
объектов.
%Мало, может ещё чего. Подробнее?

\subsubsection{Использование нескольких представлений}
Многие решения обнаружения лица используют сразу несколько представлений. Это позволяет использовать более широкий 
спектр характеристик, что делает классификатор более чувствительным к особенностям конкретного вида объектам (в 
данном случае к лицам).

Так в работе \citep{bojkovic2006face} используются три представления: пиксельное, коэфициенты собственных лиц и 
профильные коэфициенты. В работе \citep{ahmadyfard2008hierarchical} авторы используют две представления: пиксельное и 
информацию о контурах. По их словам ``объединение информации об интенсивности и о контурах даёт более описательные 
характеристики для представления изображения с лицом''.

\subsection{Задача классификации}
\label{classficators}
Задача \emph{классификации} - это проблема определение класса из всех возможных, к которому относяться 
классифицируемые объекты или наблюдения. Классификация тесно связана с \emph{машинным обучением} (\texttt{Machine 
Learning} или \texttt{ML}), задачей которого является превращение данных в информацию \citep{bradski2008learning}

Задача обнаружения лица является классическим примером задачи классификации, где есть всего два класса ``лицо'' или 
``не лицо''. Классификатор должен по данному ему изображению уметь определить к какому классу из двух оно относиться.

Все методы можно грубо разделить на две части: классификаторы основанные на знаниях (\texttt{knowledge-based}) и 
статистически обучаемые. Основанные на знаниях используют эмпирические знания о местоположении и распределении 
органических характеристик лица. \citep{bojkovic2006face} Например, факт, что глаза находятся в верхней половине 
картинки и они симметричны, а под ними находиться рот, с которым они образуют равнобедренный треугольник. Такие 
алгоритмы легко реализовать, но они неустойчивы ко многим факторам (например наклон головы).

К статистически обучаемым алгоритмам классификации относяться те, что получают заниня из данных при обучении с 
учителем или без него. Т.е. работа таких алгоритмов состоит из двух этапов: обучение и само использование. Самих 
методов очень много. Ниже приведены те, что чаще всего встречаются в обнаружении лиц. 

\subsubsection{Метод опорных векторов}
\emph{Метод опорных векторов} (\texttt{Support vector machine} или \texttt{SVM}) заключается в нахождении разделяющей 
гиперплоскости в более высокомерном пространстве, чем классифицируемые вектора. Конечная плоскость должна быть 
максимально удалено от представителей разных классов. Для этого находятся наиболее близкие к этой плоскости и тем 
самым более влиятельные векторы, которые называют опорными векторами. \citep{shavers2006svm}

Огранием SVM подхода является проблематичность использывания для классификации более чем по двум классам. Впрочем в 
данной задаче речь как раз и идёт о двух классах и SVM хорошо справляется с ней во многих работах. \citep
{shavers2006svm}, \citep{jee2004eye}, \citep{saxena2008real}
%\subsubsection{PCA}
\subsubsection{Искусственные нейронные сети}
Одним из самых популярных (но не самым эффективным) методом классификации до сих пор является искусственные нейронные 
сети (далее ИНС, \texttt{Artificial Neural Network} или \texttt{ANN}). Этот способ применяется в большинстве научных 
работ изученных в ходе подготовки данной работы, что стало одним из факторов выбора её в качестве классификатора. 

Появление ИНС было вдохновлено биологическими системами, в частности нервной системой. До определённой степени 
структура и функциональность ИНС напоминают структуры нейронных связей головного мозга (рис у8). Биологические 
нейроны это - нервная клетка, у которой есть сеть окончаний \emph{дендритов}, через которые она получает сигнал от 
других нейронов. В ядре клетки происходит суммирование всех сигналов, после чего он передаётся по длинному выходному 
окончанию \emph{аксону} на входы следующих нейронов. В ИНС всё похоже. У нейрона есть входной вектор (сеть 
дендритов), все значения которых умножаются на вес соответствующей связи и суммируются, после чего суммарный сигнал 
проходит через \emph{активационную функцию} (ядро) и результат передаётся к последующему нейрону как один из 
компонентов его входного вектора. 

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:neuron}
		\includegraphics[width=0.4\textwidth]{Pictures/neuron.jpg}
		}
	\subfloat[]{
		\label{fig:art_neuron}
		\includegraphics[width=0.6\textwidth]{Pictures/art_neuron.png}
		}
	\caption{Биологический \subref{fig:neuron} и искусственный \subref{fig:art_neuron} нейроны. На рисунке \subref
{fig:art_neuron}: $w_{1..i}$ - веса входящих соединений, $1$ - входящий сигнал, $2$ - суммирует входящие взвешенные 
сигналы, $3$ - активационная функция преобразует сумму сигналов, $4$ - результат передаётся на входы других 
нейронов.}
	\label{fig:neurons}
\end{figure}

Определяющими факторами работы ИНС являются: топология или структура сети, виды активационных функций и веса 
соединений. Веса соединений - это параметры сети, они меняются во время обучения сети, после чего сеть может 
описывать модель, которую её учат классифицировать. Главной задачей активационной функции является сжатие сигнала до 
определённых границ, а так же усиление слабых сигналов и гашении сильных. Самой популярной функциея является 
сигмойдная (TODO картинка). Она обладает всеми описанными выше требованиями к активационной функции и к тому же 
обладает простой производной, что очень удобно во время обучения методом обратного распространенея. \citep
{wasserman1989neural}

Концептуально есть две структуры ИНС: c прямым распространением сигнала (\texttt{feedforward}) и рекурентные (т.е. с 
обратными связями). Второй тип применяется для обучения без учителя (\texttt{unsupervised learning}) и в обнаружении 
используется реже, чем первый тип, к которому применяют метод обучения с учителем (\texttt{supervised learning}).

Популярным методом обучения ИНС с прямым распространением является алгоритм \emph{обратного распространения ошибки} 
(\texttt{backpropagation}) ``Он имеет солидное математическое обоснование. Несмотря на некоторые ограничения, 
процедура обратного распространения сильно расширила область проблем, в которых могут быть использованы искусственные 
нейронные сети, и убедительно продемонстрировала свою мощь.'' \citep{wasserman1989neural} Принцип метода такой: 
\begin{myItemize}
\item cначала на вход сети подаётся входной вектор, который проходит через сеть и сеть выдаёт результат;
\item разница полученного результата и заранее известного необходимого выхода (``правильного ответа'') сети 
посылается в обратном направлении от выходов к входам;
\item по мере прохождения высчитывается ошибка по методу наименьших квадратов;
\item по этим ошибке методом \emph{градиентного спуска} высчитываются изминения весов соединений. Таким образом с 
каждым новым образцом веса меняются всё лучше описывая желаемую модель.
\end{myItemize}

 У ИНС метода есть и проблемы. Что бы получить результат выше среднего сеть должна быть очень точно отрегулирована 
(число слоёв, число узлов, скорость обучения и т.д.) \citep{jee2004eye} Авторы работы \citep{capi2010vision} так же 
считают, что эффективность работы зависит от качества подстроки всей системы, и что это трудоёмкая работа. Результат 
данной работы лишний раз подтверждает эти выводы.

\section{Вспомогательные методы обнаружения лиц}

На тему обнаружения лиц написано огромное количество научных работ. В базе данных IEEE Xplore за период с 2000 года 
можно найти свыше 6000 работ, так или иначе связанных с данной тематикой. В каждой из них есть какая-то своя, 
оригинальная идея.

Так в работе \citep{jee2004eye} одной из главных характеристик поиска являются глаза, которые обнаруживаются на 
изображении при помощи SVM классификатора.

В работе \citep{capi2010vision} решается проблема создания навигационной системы робота, способной следовать за 
человеком, используя визуальную информацию. Для этого сначала обнаруживается лицо человека, а после определяется 
основной цвет его одежды. Далее человек может развернуться, и робот будет следовать за ним ориентируясь по одежде, а 
не по лицу.

Похожие задачи стоят в работе \citep{luo2007face}, где решают проблему взаимодействия человека и робота (\texttt
{Human-Robot Interaction} или \texttt{HRI}). Стоит задача обнаружения лица человека и дальнейшего слежения за ним. 
Особенностью этой работы является способ уменьшения области интереса, в которой высока вероятность обнаружения лица. 
Для этого информация о положении лица берёться из предыдущих кадров, высчитывается траектория движения лица и 
прогнозируемое следующее положение, после чего эта область расширяется на константу и в полученном месте изображения 
уже производиться поиск лица.

В работе \citep{zhang2010fast} применяется простая идея о том, что лицо человека, как и сама голова, скорее всего в 
кадре будет двигаться. Так областью интереса можно определить все движущиеся объекты. Но, такой метод предполагает 
статичную камеру и следовательно статичный фон.

(про real-time)

\chapter{Предлагаемый метод решения}
\thispagestyle{fancy}

В этой работе предлагается метод состоящий из 3 модулей, которые в совокупности образуют классический \emph
{интеллектуальный агент} (см. \ref{fig:agent}). 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\textwidth]{Pictures/Agent.eps}
	\caption{Высокоуровневая структура всей системы.}
	\label{fig:agent}
\end{figure}

Агент обладает способностью воспринимать окружающую среду через сенсоры, функцию которых выполняет веб-камера. После 
обработки полученных данных агент в каком-то роде может воздействовать на среду, вращая сервоприводы. \citep
{рассел2006искусственный}

Информация с вебкамеры поступает в модуль нахождения лиц, от куда данные о найденных лицах поступают в модуль выбора 
и слежения. Тут происходит выбор того лица за которым следить. После выбора модуль работы с сервоприводами даёт 
команду на вращение. Такая модульная структура позволяет в случае необходимости заменить тот или иной модуль. 

В предложенном решении основной програмный код написан на языке \texttt{Python}. Что бы не тратить время на решение 
уже решённые кем-то проблемы, исползуются следующие программные библиотеки:
\begin{description}
%\begin{description}

\item[OpenCV]\hfill \\
	OpenCV\footnote{Open Source Computer Vision Library. \url{http://opencv.willowgarage.com/}} - самая популярная и 
используемая библиотека компьютерного зрения с открытым исходным. Библиотека написана на \texttt{С}\textbackslash{}
\texttt{С++} и работает под \texttt{Linux}, \texttt{Windows} и \texttt{Mac OS X}. Так же разрабатываются интерфейсы 
для языков \texttt{Python, Matlab, Ruby, Lua} и других. ``Цель OpenCV - предоставить простую в использывании 
инфраструктуру компьютерного зрения, которая поможет людям строить достаточно сложные приложения.'' \citep
{bradski2008learning}
	
В данной работе используется очень интенсивно для всех манипуляций с изображением.

\item[PyBrain]\hfill \\
	PyBrain\footnote{\textbf{Py}thon-\textbf{B}ased \textbf{R}einforcement Learning, \textbf{A}rtificial \textbf{I}
ntelligence and \textbf{N}eural Network Library. \url{http://pybrain.org/}} - модульная \texttt{Python} библиотека 
машинного обучения с открытыми исходным кодом. Имеет широкий набор алгоритмов для обучения с учителем, без учителя, 
обучения с подкреплением, оптимизации типа ``чёрный-ящик'' (\texttt{black-box optimization}).
	
В данной работе библиотека используется для конструирования, обучения и приминения ИНС.

\item[NetworkX]\hfill \\
NetworkX\footnote{\url{http://networkx.lanl.gov/}} - \texttt{Python} библиотека для работы с графами. В данной работе 
нужна для поиска минимального остовного дерева.

\end{description}

\section{Модуль нахождения лица}

Модуль нахождения лица является самой большую часть данной работы, т.е. в нём сосредоточена основная логика всей 
системы. Схематически весь алгоритм представлен на рис. \ref{fig:face_detect_module1}. Каждый подмодуль соответствует 
отдельному алгоритму и он будет рассмотрен в данном разделе более подробно. (TODO Подробнее описать что да как?)

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{Pictures/face_detect_module2.eps}
	\caption{Алгоритм обнаружения лиц}
	\label{fig:face_detect_module1}
\end{figure}

\subsection{Предварительная обработка}

В данной работе как для подготовки изображения для дальнейшей работы используется метод \emph{нормализации 
гистограмм} каждого из каналов изображения. Необходимость данного этапа приведена в разделе \ref
{sec:preprocessing_theor}. Цель данного этапа получить более контрастную картинку с минимальной потерей информации и 
исправление баланса белого.

\subsubsection{Нормализации гистограмм}
Гистограмма - это графическое представление, дающее наглядное представление о распределении данных. График состоит из 
прямоугольников, которые показывают количество наблюдений (ось ординат) на данном промежутке (ось абсцисс). На 
рисунке \ref{fig:histo_sheldon} показана гистограмма распределения пиксельных интенсивностей данного (\ref
{fig:sheldon})  Ч\textbackslash{}Б изображения. Стоит отметить, что в цветном изображении у каждого цветового канала 
своя гистограмма.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:sheldon_hist}
		\includegraphics[width=0.35\textwidth]{Pictures/sheldon_hist_255.eps}
		}
	\subfloat[]{
		\label{fig:sheldon}
		\includegraphics[width=0.25\textwidth]{Pictures/sheldon.eps}
		}
	\subfloat[]{
		\label{fig:sheldon_hist_35}
		\includegraphics[width=0.35\textwidth]{Pictures/sheldon_hist_30.eps}
		}
	\caption{}
	\label{fig:histo_sheldon}
\end{figure}

В данном примере по оси абсцисс промежутками являются промежутки возможных интенсивностей. На гистограмме справа 
\subref{fig:sheldon_hist} один промежуток соответствует одному конкретному значению интенсивностей. Для 8-и битного Ч
\textbackslash{}Б изображения значение может быть от 0 до 255, где 0 - это чёрный, а 255 - белый цвета. На 
гистограмме слева \subref{fig:sheldon_hist_35} показано, что ``столбики'' (\texttt{bins}) могут объеденять значения 
на равных интервалах , показывая тем самым менее детальное распеределение между равными частями всех значений.

В случае изображений с низкой контрастностью рис. \ref{fig:low_contr1} гистограмма ``сжата'' и все значения 
сосредоточены на узком участке возможных интенсивностей рис. \ref{fig:low_contr_hist}. Как видно с гистограммы 
изображение содержит только пиксели средние интенсивности, т.е. серые цвета. По-этому на нём нету ни белого, ни 
чёрного цветов.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:low_contr1}
		\includegraphics[width=0.5\textwidth]{Pictures/low_contr_1.jpg}
		}
	\subfloat[]{
		\label{fig:hight_contr}
		\includegraphics[width=0.5\textwidth]{Pictures/low_contr_1_norm.png}
		}
		
	\subfloat[]{
		\label{fig:low_contr_hist}
		\includegraphics[width=0.51\textwidth]{Pictures/x2_b}
		}
	\subfloat[]{
		\label{fig:hight_contr_hist}
		\includegraphics[width=0.5\textwidth]{Pictures/low_contr_1_norm.eps}
		}
	\caption{Нормализация контраста ``расстяжением'' гистограммы.}
	\label{fig:contrast_norm}
\end{figure}

Что бы исправить положение и сделать изображение более интенсивным необходимо ``рас\ref{fig:hight_contr_hist}. Как 
видно после такого растяжения изображение стало более контрастным, на нём появились более тёмные и светлый цвета \ref
{fig:hight_contr}. На модифицированной гистограмме видны пробелы, они свидетельствуют о недостаточной информации и 
скачкообразных переходах интенсивностей изображения.

\subsubsection{Баланс белого цвета}

\emph{Баланс белого цвета} (реже \emph{цветовой баланс} от \texttt{color balance}) - это показатель нейтральности 
основных цветов (красный, зелёный и голубой) на изображении. Бывают ситуации, когда эта нейтральность нарушена и на 
изображении превалирует какой-то из цветов. Про такое изображение говорят, что баланс белого нарушен и необходимо 
совершить \emph{цветокоррекцию}. 

Глаз и мозг человека способны автоматически совершать цветокоррекцию, по-этому при любом освещении белый лист будет 
казаться белым. Но если тот же лист сфотографировать с неправильно выставленным балансом белого, тогда на изображении 
лист будет не белый, например желтоватый (если источник света - лампа накаливания).

На рисунке \ref{wb_norm} видно, что на всём изображении превалирует красноватый цвет. Это говорит о том, что все 
цвета не совсем соответствуют своему истинному значению. Авто не нашёл  в источниках информации о том, как 
проивзводить цветокоррекцию. Но, наблюдая за тем, как меняются гистограммы (цветовых каналов) изображения после 
цветокоррекции в профессиональных фото-редакторах, была замечена закономерность. На рисунке \ref{fig:wb_pic_hist} 
видно, что гистограммы не нормализированны (при чём по разному), а те же гистограммы \ref{fig:wb_pic_hist_norm}, но 
уже изображения с правильным балансом белого \ref{fig:wb_pic_norm} - нормализированна. От сюда предположение, что для 
того что бы поправить баланс белого нужно нормализировать гистограммы всех каналов по отдельности, что исправит и 
контрастность тоже.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:wb_pic}
		\includegraphics[width=0.5\textwidth]{Pictures/x3_a.jpg}
		}
	\subfloat[]{
		\label{fig:wb_pic_norm}
		\includegraphics[width=0.5\textwidth]{Pictures/x3_a_norm.png}
		}
		
	\subfloat[]{
		\label{fig:wb_pic_hist}
		\includegraphics[width=0.5\textwidth]{Pictures/x3_b}
		}
	\subfloat[]{
		\label{fig:wb_pic_hist_norm}
		\includegraphics[width=0.52\textwidth]{Pictures/x3_v}
		}
	\caption{Нормализация баланса белого ``расстяжением'' гистограммы разных каналов по отдельности.}
	\label{fig:wb_norm}
\end{figure}

В OpenCV уже есть функция, которая делает такое ``расстяжение'' гистограммы для всех интенсивностей изображения - 
\texttt{Normalize}. С помощью неё можно в любой матрице получить распределение в указанных пределах пропорционально 
тем значениям, что в ней уже есть. Для получения желаемого результата, нужно в качестве аргумента подать матрицу 
интенсивностей пикселей изображения, а в качестве границ 0 и 255.

Но иногда этого не достаточно. Бывают случаи, когда изображение мало-контрастно на большей своей части, при этом 
имеются небольшие участки с сильно тёмными или светлыми облостями. В таком случае \texttt{Normalize} не будет работать так как нужно. На рисунке \ref{fig:contrast_norm} показан случай, когда метод работает, без дополнительных манипуляций. А на рисунке \ref{fig:without_agrassive} видно, что б\`{о}льшая часть интенсивностей так и осталась в среднем, ``сером'' промежутке.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:without_agrassive}
		\includegraphics[width=0.5\textwidth]{Pictures/x4_a.eps}
		}
	\subfloat[]{
		\label{fig:with_agrassive}
		\includegraphics[width=0.5\textwidth]{Pictures/x4_b.eps}
		}
	\caption{}
	\label{fig:aggresive_normal}
\end{figure}

Во время работы процедуры \texttt{Normalize} информация не теряется, а просто перераспределяется, т.е. это обратимый 
процесс. Что бы в случае \ref{fig:sheldon_hist} на картинке \ref{fig:sheldon} ``рясстянуть'' зону до пунктирной линии \ref{fig:with_agrassive} (верхняя гистограмма), т.е. сделать контрастным 
большую часть изображения \ref{fig:with_agrassive} (нижняя гистограмма), необходимо лишиться некоторой информации. Следующий алгоритм находит верхнюю и нижнюю границы, область между которыми нужно ``рясстянуть'':

\begin{algorithmic}[1]
\STATE $mostPopColor\gets $ \emph{Самая распространённая интенсивность (цвет)}
\STATE $mostPopColorCount\gets histValueAt(mostPopColor)$ 
%\COMMENT{Количество пикселей с интенсивностью $mostPopColor$}
\STATE $threshold\gets mostPopColorCount\times{aggression}$
\FOR{$i = 0$ \TO $255$} 
\STATE $downV\gets histValueAt(i)$
\STATE $upV\gets histValueAt(255-i)$
\IF{$downT \neq NIL$ \AND $downV > threshold$}
\STATE $downT\gets downValue$
\ENDIF
\IF{$upT \neq NIL$ \AND $upV < threshold$}
\STATE $upT\gets upV$
\ENDIF
\ENDFOR
\FOR{$p \in pixels$} 
\IF{$p < downT$}
\STATE $p\gets downT$
\ELSIF{$p > upT$}
\STATE $p\gets upT$	
\ENDIF
\ENDFOR
\end{algorithmic}

Здесь процедура $histValueAt(color)$ возвращает количество пикселей с данной интенсивностью (т.е. высоту ``столбика'' 
на гистограмме), а $aggression$ - константа, показывающая на сколько сильно будет ``рясстянута'' гистограмма. После 
применения данной процедуры все пиксели с интенсивностью до $downT$ и свыше $upT$ преобретают значения этих границ. 
Это проиллюстрировано на рисунке \ref{fig:aggresive_normal_steps} (\subref{fig:x5_a} и \subref{fig:x5_b}).


\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:x5_a}
		\includegraphics[width=0.32\textwidth]{Pictures/x5_a.eps}
		}
	\subfloat[]{
		\label{fig:x5_b}
		\includegraphics[width=0.32\textwidth]{Pictures/x5_b.eps}
		}
	\subfloat[]{
		\label{fig:x5_c}
		\includegraphics[width=0.32\textwidth]{Pictures/x5_c.eps}
		}
	\caption{}
	\label{fig:aggresive_normal_steps}
\end{figure}

После такой обработки можно уже применять процедуру \texttt{Normalize} (рис. \ref{fig:x5_c}), которая пропорционально 
распределит все интенсивность от $0$ до $255$.

\subsection{Поиск зон с цветом кожного прокрова}
\label{sec:skin_detection}
Как было отмечено в \ref{sec:skin_segm} для ускорения работы алгоритма обнаружения можно уменьшить область 
сканирования путём поиска частей изображения с цветом кожного покрова. Но это не единственное применение. Напрмер, 
для того что бы оградить детей от изображений ``только для взрослых'', применяют алгоритмы поиска областей с цветом 
кожи, т.к. подобные изображения часто имеют большую площадь этих областей. \citep{forsyth1999automatic} \citep
{zheng2004blocking}

\subsubsection{Возможные пути решения}
Задачу поиска области с цветом кожи как и задачу обнаружения лица можно представить как проблему классификации с 
двумя классами: ``кожа'' и ``не кожа''. Следовательно как и классификацией лиц тут есть два основных направления: 
метод основанный на знании и статистические обучаемые, которые в свою очередь деляться на параметрические и 
непараметрические. \citep{vezhnevets2003survey}

Все обучаемые алгоритмы строят модель цвета кожи на основе тренировочных образцов. Параметрическая модель 
представляет собой набор параметров, описывающих некую область в цветовом пространстве, зачастую используя только 
плоскости цветности этих пространств. Плюсом этих методов является компактность полученной модели. Примерами таких 
алгоритмов являются нормальные распределения и различные элиптические и модели.

Непараметрические методы строят модель на основе статистических распределений в тренеровочных примерах. В результате 
получаются т.н. карта распределения цвета кожи (\texttt{Skin Probobility Map}), которая определяет вероятность 
принадлежности каждого из возможных цветов к классу "кожа" или более формально $P(skin|c)$ - вероятность наблюдения 
кожи ($skin$), если дан цвет $c$. Примерами таких алгоритвоя являются \emph{Наивный байесовский классификатор}, \emph
{Самоорганизующаяся карта Кохонена} (\texttt{Self-organizing map} или \texttt{SOM}) и ИНС (в \citep{xu2006color} 
последнии два называют полупараметрическими, т.к. параметры там всё же есть, но их число неопределено)

К основанным на знание относятся два метода: с статическим и динамическим определением границ. В обоих случаях для 
того, что бы классифицировать определённый цвет он должен входить в определённые рамки в цветовом пространстве (в 
трёхмерном цветовом пространстве - это ограничивающие плоскости). Конкретные границы определяются эмпирически. В 
методах со статическим определением они задаются изначально и не меняются, а в динамических границы могут 
адаптировать к текущему цвету лица или условиям освещённости. 

%В данной работе применяется два разных набора статических границ.
\subsubsection{Проблема выбора цветового пространства}
Параллельно с выбором метода обнаружения кожи необходимо выбрать цветовое пространство в котором будет оперировать 
выбранный метод. Выбор цветового пространства можно считать важным шагом на пути классификации цвета кожи. Самым 
распространённым является \texttt{RGB}, компонентами которого являются интенсивности трёх основных цветов (красного, 
зелёного и синего). Координаты цвета в другом пространстве можно получить линейную или нелинейную трансформацию из 
\texttt{RGB}. \cite{kakumanu2007survey} 

\texttt{RGB} пространство не является удобным для поиска цветов кожи, т.к. само понятие ``цвет кожи'' - это не 
физическое свойство объекта, а скорее явление связанное с восприятие человеком, по-этому и хороших результатов в 
обнаружении можно достигнув только использовав цветовые пространства обладающие схожими свойствами. К таким 
пространствам относится нормализированное \texttt{RGB} пространство, где сумма всех трёх компонент равны единице ($r
+g+b=1$) Это уменьшает зависимость от света. \citep{vezhnevets2003survey}

Другой популярной группой пространств являетются \texttt{HSV}, \texttt{HSI} и \texttt{HSL}. Они описывают цвет 
интуитивными понятиями, основаны на художественных представлениях о краске (\texttt{Tint}), насыщенности (\texttt
{saturation}) и тон. Так \texttt{H} (\texttt{Hue}) показывает доменирующий цвет (красный, зелёный, жёлтый, фиалетовы 
и т.д.), \texttt{S} (\texttt{Saturation}) измеряет насыщенность краски по отнашению пропорционально её освещённости. 
Последняя компонента \texttt{V}, \texttt{I} и \texttt{L} относяться к величине якрости. Таким образом \texttt{HSV} 
чётко отделяет цветность от яркости, что полезно в алгоритмах обнаружения кожи. \citep{vezhnevets2003survey}

Ещё одним очень популярным цветовым пространством является \texttt{YC$_r$C$_b$}. Цвет в этом пространстве представлен 
яркостной составляющей \texttt{Y} (\texttt{luma}), и двумя цветовыми составляющими \texttt{C$_r$} и \texttt{C$_b$}, 
показывающих разницу соотстветствующих компонент \texttt{RGB} от \texttt{Y}. Это цветовое пространство как и \texttt
{HSV} разделяет цвет на цветность и яркость. \citep{vezhnevets2003survey}

Важным вопросом при выборе цветового пространства является его эффективность для конкретной задачи обнаружения кожи 
человека. В ряде работ приводятся доводы в пользы того или иного пространства, в других же эти выводы подвергаются 
сомнению и говориться, что от выбора цветового пространства эффективность сильно не зависит. Так же часто поднимается 
вопрос о необходимости вовлечении яркостной компоненты (\texttt{V}\textbackslash{}\texttt{I}\textbackslash{}\texttt
{L} для \texttt{HSV} и \texttt{Y} для \texttt{YC$_r$C$_b$}) в классификацию, ведь как говорилось выше (\ref
{sec:skin_segm}) цвет кожи в основном меняется именно в нём, и было бы логичным отбросить этот компонент, что бы 
алгоритм стал более стабилен. Так поступают во многих изученных работах, например в \citep{mohamed2008face}. Но, в 
работе \citep{xu2006color} приводиться сравнительный анализ использования различных цветовых пространств с и без 
яркостной составляющих, из которого видно, что её отбрасывание не ведёт к улучшению эффективности и даже ухудшает её.

\subsubsection{Метод статического диапозона}
В данный работе для обнаружения областей с цветом кожи, применяется самый простой, при этом достаточно действенный 
метод статических диапазонов. Для сравнения были опробованы 2 набора диапазонов из разных работ. В наборе условий 
\ref{eq:lin2005skin_cond1} - \ref{eq:lin2005skin_cond4} приведены условия, при которых пиксель принадлежит к коже по 
мнению авторов \citep{lin2005face}.

\begin{equation}
\label{eq:lin2005skin_cond1}
\centering
R>G, |R-G|\geq{11}, 
\end{equation}
\begin{equation}
\label{eq:lin2005skin_cond2}
\centering
0.33\leq{r}\leq{0.6}, 0.25\leq{g}\leq{0.37},
\end{equation}
\begin{equation}
\label{eq:lin2005skin_cond3}
\centering
340\leq{H}\leq{359} \lor 0\leq{H}\leq{50},
\end{equation}
\begin{equation}
\label{eq:lin2005skin_cond4}
\centering
0.12\leq{S}\leq{0.7}, 0.3\leq{V}\leq{1.0}
\end{equation}

(TODO где, ... надо ли. Прошли подробно все вроде)

В работе \citep{vezhnevets2003survey} приводиться похожий, но другой набор условий \ref{eq:vezhnevets2003_cond1}-\ref
{eq:vezhnevets2003_cond3}.

\begin{equation}
\label{eq:vezhnevets2003_cond1}
\centering
R>95, G>40, B>20,
\end{equation}
\begin{equation}
\label{eq:vezhnevets2003_cond2}
\centering
max\{R,G,B\} - min\{R,G,B\} > 15,
\end{equation}
\begin{equation}
\label{eq:vezhnevets2003_cond3}
\centering
|R - G| > 15, R > G, R > B
\end{equation}

Для реализации метода сначала выделются и получаются отдельные каналы, после чего каждое отдельное условие приводит к 
получению бинарной маски. Т.е. например для реализации первой части условия \ref{eq:vezhnevets2003_cond1} необходимо 
взять цветовой канал \texttt{R} и применив функцию $InRangeS(0, 95) -> mask$, получить изображение, на котором в тех 
местах, где условие удовлетворяется будет белый, а где нет - чёрный. Такие маски получаются для всех условий, после 
чего они объединяются логическим ``И'', таким образом оставив в результирующей маске только те участки, который 
удовлетворяют всем условиям. Пример работы второго набора условий показан на рисунке \ref{fig:skin_mask_example}.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:skin_sample}
		\includegraphics[width=0.4\textwidth]{Pictures/dr_house_2.jpg}
		}
	\subfloat[]{
		\label{fig:skin_sample_mask}
		\includegraphics[width=0.4\textwidth]{Pictures/dr_house_skin_mask.png}
		}
	\caption{Пример работы поиска областей с цветом кожи. Реультирующая маска \subref{fig:skin_sample_mask}, полученная приминением условий \ref{eq:vezhnevets2003_cond1}-\ref{eq:vezhnevets2003_cond3} к изображению \subref{fig:skin_sample}}
	\label{fig:skin_mask_example}
\end{figure}

\subsection{Выделение и объединение областей с цветом кожного покрова}

Бинарное изображение, получаемой не выходе из \ref{sec:skin_detection} представляет из себя просто информацию о 
пиксельной интенсивности. Для дальнейшей работы, из этих данных нужно получить более интуитивные данные, например 
контуры. 
\subsubsection{Выделение найденных областей}
В OpenCV есть ряд функий для работы с контурами, которые могут из любого изображения получить информацию о замкнутых 
линиях проходящих по границе контрастных районов изображения. Бинарное изображение как нельзя лучше подходит для 
получения чётких контуров.

На рисунке \ref{fig:countour_process} показан процесс предобразования бинарной маски в отдельные контуры.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:mask}
		\includegraphics[width=0.20\textwidth]{Pictures/x7_mask}
		}
	\subfloat[]{
		\label{fig:dilate}
		\includegraphics[width=0.20\textwidth]{Pictures/x7_dilate}
		}
	\subfloat[]{
		\label{fig:cont}
		\includegraphics[width=0.20\textwidth]{Pictures/x7_cont}
		}
	\subfloat[]{
		\label{fig:cont_ins}
		\includegraphics[width=0.20\textwidth]{Pictures/x7_cont_ins}
		}
	\subfloat[]{
		\label{fig:aprox}
		\includegraphics[width=0.20\textwidth]{Pictures/x7_aprox}
		}
	\caption{Процесс получения контуров вокруг областей, содержащих цвет кожи.}
	\label{fig:countour_process}
\end{figure}


Алгоритм выделения из маски контуров состоит из 4 этапов:
\begin{description}
\item[\subref{fig:mask}] Сперва изображение с маской проходит процесс открытия или расширения (\texttt{dilate}) c одним шагом. Это 
необходимо для того, что бы замкнуть пограничные области. В OpenCV за это отвечает функция 
$dilate()$.
\item[\subref{fig:dilate}] Далее высчитываются все имеющиеся контуры. За это в OpenCV отвечает функция $FindContours()$. Результат 
процедуры возвращает в виде списка отдельных замкнутых контуров, которые представлены в виде последовательности 
координат точек, образующих контур.
\item[\subref{fig:cont}] Из всех контуров остаются только внешние, тем самым отфильтровываются внутренние ``дыры'', которые в 
будущем не потребуются.
\item[\subref{fig:cont_ins}] Текущие контуры ``заливаются'' и получается бинарная маска, которая проходит процесс двухкратного закрытия 
или зжатия (\texttt{erode}). Это избавляет от очень мелких контуров и так же разьеденяет те контуры, которые 
соеденены маленькими ``мостиками'', т.к. зачастую эти контуры описывают разные объекты.
\item[\subref{fig:aprox}] Последним шагом убераются лишняя детальность контурной линии, она апроксимируется, в следствии чего 
уменьшаяется число описывающих контур вершин.
\end{description}

В результате имеется список контуров, описывающих небольшим количеством вершин отдельные области на изображении, где 
встречается цвет кожи.

\subsubsection{Кластеризация}
Как будет показано в .... выбранный способ классификации областей с цветом кожи не всегда работает. Бывают случаи, 
когда цвет кожи на лице человека обнаруживается не на всей площади, а небольшими участками. В результате эти участки 
будут просканированны и ничего не будет найдено. Для этого необходимо объединить эти участки в один \ref{fig:cluster_example}. Ещё одна 
проблема, которую может решить объединение - это перекрывающиеся прямоугольники, которые обводят вокруг каждой 
области, для дальнейшей работы.

Подобные объединения называются кластерами, а сам процесс - кластеризацией. Методов кластеризации много. Самым 
простым и популярным является метод ``\texttt{k-mean}''. Его реализация есть даже в библиотеке OpenCV. Минусом этого 
алгоритма является то, что необходимо указывать количество конечных кластеров. В данном случае это количество 
неизвестно. Но даже зная количество, k-mean кластеризует не достаточно интуитивно и полезно для данной задачи.
%For Paper variant - (рис х8)
 Для кластаризации областей в качестве объекта кластеризации используются центры прямоугольников, обведённых 
вокруг контуров.

Интуитивным решением кажется объеденять те точки, что находяться близко друг к другу, и разъеденять те, что далеко. 
Для этого все точки надо соеденить так, что бы   расстояние этих соединений было минимальным. Это нужно, что бы найти 
самые удалённые друг от друга точки. В результате точки и их соединения образуют незамкнутый граф или дерево, а 
точнее \emph{минимальное остовное дерево}  (МОД) (\texttt{Minimum spanning tree}). Для получения МОД используется 
библиотека \texttt{NetworkX}, а в качестве весов рёбер выступает эвклидово расстояние между точками. Пример остовного 
дерева, полученного из центров прямоугольников описанных вокруг контуров, показан на рисунке \ref{fig:mst}.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\label{fig:x9_a}
		\includegraphics[width=0.5\textwidth]{Pictures/x9_a}
		}
	\subfloat[]{
		\label{fig:x9_b}
		\includegraphics[width=0.5\textwidth]{Pictures/x9_b}
		}
	\caption{Пример минимального остовного дерева, где вершины - это центры прямоугольников обведённых вокруг контуров.}
	\label{fig:mst}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{Pictures/x10}
	\caption{Пример удачного использования объединения разрозненных участков в один.}
	\label{fig:cluster_example}
\end{figure}


Для кластеризации используется, описанный в работе \citep{grygorash2006minimum} метод HEMST (\texttt{hierarchical 
euclidean minimum spanning tree}). Алгоритм как и \texttt{k-mean} требует в качестве аргумента количество желаемых 
кластеров, но работает он значительно интуитивнее применительно к данной проблеме. Суть работы сводиться к удалению 
самых длинных рёбер в дереве, но до определённого предела (пока есть значительно длинные рёбра по отнашению к 
остальным), после чего дерево апроксимируется и опять удаляются самые длинные рёбра.

После объединения в кластеры, прамоугольные области входящие в один кластер будут заменены прямоугольным регионом, 
описанным вокруг тех, что входят в кластер. Для определения оптимального количества кластеров применяется алгоритм 
(см. ... ), который сравнивает сумму площедей прямоугольников, входящих в кластер с площадью прямоугольника вокруг 
всего кластера (строка 11), если отношение удовлетворяет некоторому порогу (строка 12), то такое слияние принимается.
\begin{algorithmic}[1]
\STATE $boxes \gets initialBoxes$
\STATE $threshold \gets initialThreshold$
\STATE $loan \gets 0$
\REPEAT
\STATE $initSize \gets length[boxes]$
\FOR{$k \gets initSize$ \TO $1$}
\STATE $forMerge \gets []$
\FOR{$cluster \in HEMST(boxes, k)$}
\STATE $bRect\gets BOUNDING\_RECT(cluster)$
\STATE $clBoxes\gets boxes \in cluster$
\STATE $rel\gets sqrt(BOXES\_AREA(clBoxes))/sqrt($площадь $bRect)$
\IF{$rel > threshold$}
\STATE $loan \gets loan + (1 - rel)$
\STATE $forMerge[length+1] \gets [bRect, clBoxes]$
\ENDIF
\ENDFOR
\STATE $boxes[i] \in forMerge[i][1] \gets NIL$
\STATE $boxes[length+1] \gets forMerge[][0]$
\STATE $threshold \gets threshold + speedConst + loan/k$
\ENDFOR
\UNTIL{$initSize \neq length[boxes]$}
\end{algorithmic}
Тут $k$ - число кластеров, $initialBoxes$ - все начальные регионы вокруг контуров, $initialThreshold$ - константа 
определяющая допустимое отношение квадратов площадей, $speedConst$ - константа уменьшающая допустимый порок по мере 
расширяющегося последовательного объединения. 

В алгоритме ...  для подсчёта площади регионов, входящих в кластер, используется функция $BOXES\_AREA(boxes)$. Это 
функция высчитывает только ту площадь, которую занимают прямоугольники все вместе. Т.е. в случае, если они 
накладываются друг ну друга, то места наложения считаются один раз. Для этого используется алгоритм скользящей линии 
(\texttt{Sweep line algorithm}). Суть алгоритма в том, что вертикальная скользящяя линии передвигается слева направа 
и регистрирует события встречаясь с правыми и левыми стороны прямоугольников. События встречи с левыми сторонами 
активируют эти прямоугольники, а с правой деактивируют. После каждого события горизонтальная скользящая линяя 
проходит сверху вниз и точно так же регистрирует события верхних и нижних границ, но только активных прямоугольников. 
На момент каждого события горизонтальной линии можно вычислить расстояние между текущей и предыдущей позициями как 
горизонтальной, так и вертикальной линий. Эти расстояние надо перемножать и получившиеся площади складывать. В 
результате получается площадь занятой прямоугольниками фигуры.

(картинки тут явно надо)
(TODO - надо ли этот рассказ вообще)

%\subsection{Фильтрация по пропорциям и заполненности}
%Описание возможного постпроцессинга для отфильтровывания неподходящих участков.
\subsection{Классификация}

%Описание проблеммы классификации в целом.
%Опять о том какие методы бывают. О том, что сейчас применяют чаще.
\subsubsection{Выбор метода ИНС для классификации}
Почему выбрал ann? (real-time, простота понимания и использования)

Как это делают другие?
\subsubsection{Описание сети}
Несколько сетей для разных представлений. B/w, Edges

О проблемах недофитинга и overfit'инга.

Описание структуры ИНС. Почему именно такая.

bias'ы, преждевременная остановка, ...

Код с сосзданием сети.
\subsubsection{Обучение сети}
Первый этап.

Проблема и важность выбора примеров для обучения.

Применяемые базы лиц, усреднённые лица, возможная рамочка

Проблема выбора "не лиц".

Описание подготовки выборок для тренировки и тестирования.

Код PyBrain по тренеровки сети.
\subsubsection{Применение сети}
Сохранение и загрузка обученной сети.

Понятие порога.

sliding window алгоритм. диаграмы, код.

Кластеризация всех найденных лиц в группы, что бы отсечь случайные Flase positives. Overlap'ы и всё такое.
\section{Выбор цели для слежения}
найти наибольшее лицо

искать ближайшее к тому, за которым уже следим
\section{Механическая часть}
Работа с сервоприводами
\subsection{описание установки для демонстрации}
arduino,
сервоприводы,
камеры
\subsection{Подсчёт вектора движения}
\subsection{Arduino}
коммуникация c PC

листинги кода, диаграммы (этого нет =/ )


\chapter{Результаты работы (Испытания?)}
%\addcontentsline{toc}{chapter}{Результаты работы (Испытания?)}
\thispagestyle{fancy}

\section{Автоконтраст и баланс белого}
Когда работает? А когда не очень? примеры и того и того.

Возможные пути решения.
\section{Поиск зон с кожным покровом}
Когда работает? А когда не очень? примеры и того и того.

Пути решение. (Другой метод, выбор более узкой области диапазонов. - пример возможного приложения для сбора образцов)

О том что хорошо, что больше false negative, чем false positive
\section{Объединение областей}
Примеры хорошой и плохой работы.

Как можно улучшить. (выбор другого алгоритма выбора цвета кожи, подгонка параметров кластеризации)
\section{(Результаты) работа с ИНС}
\subsection{Различные представления}
Почему представление с пограничными областями не работает. Усреднённые морды где видно проблему. Как-то улучшить 
алгоритм выявления пограничных областей? Какие-то другие представления?
\subsection{(Результаты) обучения и тестирования}
Цифры, проценты результативности на тестовых данных. False positive, False negative. Примеры неузнанных лиц, примеры 
узнанных не лиц. Усреднённые нелица, усреднённые ненайденные лица.
Как можно улучшить?

- Правильная структура сети, выделяющая характеристики (features)

- Более тщательный подбор примеров (глаза на одном месте, одна ореинтация)

- Разные классы для разных поз (направление взгляда - прямо, вверх, вниз, вправо, влево)

- Икрементальный процесс обучения (где все falses из тестового набора добавляются обратно в набор обучения)
\section{Выбор лица и arduino}
Так и не успел закончить эту часть. Что писать в результатах пока не знаю.
\section{Испытание всей системы}
результаты испытаний.

небольшие ошибка на всех уровнях в итоге дают неудовлетворительный результат. улучшать необходимо каждый из элементов 
в отдельности.

- о проблеме 2-7 процентах на 97 000 примерах с одного кадра. Много false positive. Сложно настроить правильные 
порог.

- о проблеме со скорость. Решение - оптимизация и использование psyco.

\chapter*{Заключение и выводы}
\addcontentsline{toc}{chapter}{Заключение и выводы}
\thispagestyle{fancy}


\appendix
\chapter{Приложение. Отчёт по курсовой практике}
%\pagebreak
%-

%\clearpage
%\pagebreak
%-

%\clearpage
%\pagebreak
%-

%\clearpage
%\pagebreak
%-
%\clearpage


%\clearpage

\addcontentsline{toc}{chapter}{Литература}

\bibliographystyle{plainnat}
\bibliography{biblio}

\end{document}  